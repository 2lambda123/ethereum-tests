#! /usr/bin/node


// Generate a test that looks at all the opcodes and checks which are valid
// and which aren't.
//
// Usage:
// ./validInvalidOpcodeGen.js > ../../GeneralStateTestsFiller/stBadOpcode/validInvalidOpcodeFiller.yml


// The opcode ranges for valid opcodes, for each supported release
const validOpcodesByFork = {
   // List of [from,to] when from-to are valid opcodes
   'London': [[0x01,0x0B], [0x10,0x1D], [0x20,0x20], [0x30,0x48], [0x50,0x5B],
              [0x60,0xA4], [0xF0,0xF5], [0xFA,0xFA], [0xFD,0xFD]],
   'Merge':  [[0x01,0x0B], [0x10,0x1D], [0x20,0x20], [0x30,0x48], [0x50,0x5B],
              [0x60,0xA4], [0xF0,0xF5], [0xFA,0xFA], [0xFD,0xFD]]

}



// Turn a byte numeric value into hex
const byte2Hex = n => n>15 ? n.toString(16) : "0"+n.toString(16)

const opcode2Addr = op => `0x7E57C0DE000000000000000000000000000000${byte2Hex(op)}`

// 33 NOPs (a.k.a. JUMPDESTs). Added so that we'll be able to check opcodes with
// immediate parameters (PUSHn, and eventually relative jumps)
const nop33 = "5b5b5b5b" + "5b5b5b5b" + "5b5b5b5b" + "5b5b5b5b" +
              "5b5b5b5b" + "5b5b5b5b" + "5b5b5b5b" + "5b5b5b5b" +
              "5b"



// Exceptions that cannot be tested using the standard method (because they jump
// to a non JUMPDEST)
const exceptionTestCode = {
  0x56: `
       #  0 PUSH 1 4  6004
       #  2 JUMP        56
       #  3 INVALID     FE
       #  4 JUMPDEST    5B
       #  5 PUSH1 0   6001
       #  7 PUSH1 1   6000
       #  9 RETURN      F3
       code: :raw 0x6004-56-FE-5B-6001-6000-F3
`,
  0x57: `
       #  0 PUSH 1 1  6001
       #  2 PUSH 1 6  6006
       #  4 JUMPI       57
       #  5 INVALID     FE
       #  6 JUMPDEST    5B
       #  7 PUSH1 0   6001
       #  8 PUSH1 1   6000
       #  9 RETURN      F3
       code: :raw 0x6001-6006-57-FE-5B-6001-6000-F3

`
}


const getTestCode = op => {
if (exceptionTestCode[op])
   return exceptionTestCode[op]
return `
       code: |
         :yul {
             // A call to have return data
             pop(call(gas(), 0xca11ed, 0, 0,0, 0,0))


             // Run the opcode, assume 20 parameters are enough
             verbatim_20i_0o(hex"${byte2Hex(op)}${nop33}", 1, 1, 3, 4, 5, 6, 7, 8, 9, 10,
                                                  11,12,13,14,15,16,17,18,19,20)

             // If we get here, return one byte. That would be the sign of success
             return(0,1)
         }


`
}

const contract = op =>
`
    ${opcode2Addr(op)}:
       balance: 0
       nonce: 1
       storage: {}
${getTestCode(op)}
`


ops = Array.apply(null, {length:256}).map(eval.call, Number)
opContracts = ops.map(contract).reduce((a,b) => a+b)



const expectOpcode = op => `
            0x${byte2Hex(op)}: 1`


const expectOpcodes = (lst) => {
    retVal = ""
    for(var i=lst[0]; i<=lst[1]; i++)
        retVal += expectOpcode(i)

    return retVal
}

const forks = Object.keys(validOpcodesByFork)

const fork2expect = fork => `
    - indexes:
        data:  !!int -1
        gas:   !!int -1
        value: !!int -1
      network:
        - ${fork}
      result:
        cccccccccccccccccccccccccccccccccccccccc:
          storage:
            # Zero if there is no opcode, 1 if there is
            # 0x00 STOP is an opcode, but one that cannot be detected by this test.
            # 0xFF SELFDESTRUCT may be an opcode,
            # but one that cannot be detected by this test.
${validOpcodesByFork[fork].
	map(x => expectOpcodes(x)).
	reduce((a,b) => a+b)
}
`


testFiller = `
validInvalidOpcode:

# Do not manually edit this file. It is generated by
# validInvalidOpcodeGen.js

  _info:
    comment: Ori Pomerantz qbzzt1@gmail.com

  env:
    currentCoinbase: 2adc25665018aa1fe0e6bc666dac8fc2697ff9ba
    currentDifficulty: 0x20000
    currentGasLimit: 0xFF112233445566
    currentNumber: 1
    currentTimestamp: 1000
    previousHash: 5e20a0453cecd065ea59c37ac63e079ee08998b6045136a8ce6635c7912ec0b6
    currentBaseFee: 10


  pre:

    # Contract called by the test code to have return data
    0000000000000000000000000000000000ca11ed:
      balance: 0
      nonce: 1
      storage: {}
      code: |
          :yul {
               mstore(0, 0xDEAD60A7)
               return(0x1C, 4)
          }


    # Contract called by the transaction
    cccccccccccccccccccccccccccccccccccccccc:
      balance: 0
      code: |
          :yul {
              let opcodeTestBase := 0x7E57C0DE00000000000000000000000000000000

              // For every possible opcode
              for { let op := 0x00 } lt(op,0x100) { op := add(op,1) } {
                 pop(call(60000, add(opcodeTestBase, op), 0, 0,0, 0,0))
                 sstore(op, returndatasize())
              }     // for loop
          }
      nonce: 1
      storage: {}

    a94f5374fce5edbc8e2a8697c15331677e6ebf0b:
      balance: 1_000_000_000_000
      code: '0x'
      nonce: 1
      storage: {}


${opContracts}

  transaction:
    data:
    - 0x
    gasPrice: 100
    gasLimit:
    - 100_000_000
    nonce: 1
    to: cccccccccccccccccccccccccccccccccccccccc
    value:
    - 0
    secretKey: "45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d8"


  expect:

${forks.map(fork2expect).reduce((a,b) => a+b)}
`


console.log(testFiller)
