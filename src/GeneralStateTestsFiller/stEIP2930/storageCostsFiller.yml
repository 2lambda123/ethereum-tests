storageCosts:

  env:
    currentCoinbase: 2adc25665018aa1fe0e6bc666dac8fc2697ff9ba
    currentDifficulty: '0x20000'
    currentGasLimit: '0xFF112233445566'
    currentNumber: '1'
    currentTimestamp: '1000'
    previousHash: 5e20a0453cecd065ea59c37ac63e079ee08998b6045136a8ce6635c7912ec0b6



  _info:
    comment: Ori Pomerantz qbzzt1@gmail.com


  pre:
    # Declared vs. undeclared write (SSTORE)    zero -> value
    0000000000000000000000000000000000000100:
      balance: '1000000000000000000'
      code: |
       { 
        ; Write to @@0, and see how much gas that cost. It should
        ; cost more when it is not declared storage
          [0]   (gas)
         [[0]]  0x02 
          [0]   (- @0 (gas) 17)
         [[1]] @0

        ; The 17 is the cost of the extra opcodes:
        ; PUSH1 0x00, MSTORE
        ; PUSH1 0x02, PUSH1 0x00, (and then comes the SSTORE we are measuring)
        ; GAS

        ; If the storage cell is declared the cost in @@1 should be 20003
        ; If the storage cell is not declared the cost    should be 22103
       }
      nonce: '0'
      storage: {}



    # Declared vs. undeclared read (SLOAD)
    0000000000000000000000000000000000000101:
      balance: '1000000000000000000'
      code: |
       { 
        ; Read @@0, and see how much gas that cost. It should
        ; cost more when it is not declared storage
          [0]   (gas)
          @@0 
          [0]   (- @0 (gas) 19)
         [[1]] @0

        ; If the storage cell is declared the cost in @@1 should be  100
        ; If the storage cell is not declared the cost    should be 2100
       }
      nonce: '0'
      storage: {}



    # Declared vs. undeclared delete     value -> zero
    0000000000000000000000000000000000000102:
      balance: '1000000000000000000'
      storage:
        0x00: 0x60A7
      code: |
       { 
        ; Write to @@0, and see how much gas that cost. It should
        ; cost more when it is not declared storage
          [0]   (gas)
         [[0]]  0x00 
          [0]   (- @0 (gas) 17)
         [[1]] @0

        ; The 17 is the cost of the extra opcodes:
        ; PUSH1 0x00, MSTORE
        ; PUSH1 0x02, PUSH1 0x00, (and then comes the SSTORE we are measuring)
        ; GAS

        ; If the storage cell is declared the cost in @@1 should be 2903
        ; If the storage cell is not declared the cost    should be 5003
        ;
        ; The refund for freeing memory happens at the end of the transaction,
        ; so we don't see it
       }
      nonce: '0'




    # Declared vs. undeclared update     value -> different value
    0000000000000000000000000000000000000103:
      balance: '1000000000000000000'
      storage:
        0x00: 0x60A7
      code: |
       { 
        ; Write to @@0, and see how much gas that cost. It should
        ; cost more when it is not declared storage
          [0]   (gas)
         [[0]]  0xBEEF
          [0]   (- @0 (gas) 17)
         [[1]] @0

        ; The 17 is the cost of the extra opcodes:
        ; PUSH1 0x00, MSTORE
        ; PUSH1 0x02, PUSH1 0x00, (and then comes the SSTORE we are measuring)
        ; GAS

        ; If the storage cell is declared the cost in @@1 should be  103
        ; If the storage cell is not declared the cost    should be 2203
       }
      nonce: '0'




    # Declared vs. undeclared NOP     value -> same value
    0000000000000000000000000000000000000104:
      balance: '1000000000000000000'
      storage:
        0x00: 0x60A7
      code: |
       { 
        ; Write to @@0, and see how much gas that cost. It should
        ; cost more when it is not declared storage
          [0]   (gas)
         [[0]]  0x60A7
          [0]   (- @0 (gas) 17)
         [[1]] @0

        ; The 17 is the cost of the extra opcodes:
        ; PUSH1 0x00, MSTORE
        ; PUSH1 0x02, PUSH1 0x00, (and then comes the SSTORE we are measuring)
        ; GAS

        ; This costs 103, regadless of whether it is declared or not
       }
      nonce: '0'






    # Declared vs. undeclared write (SSTORE), after writing to the storage
    0000000000000000000000000000000000000110:
      balance: '1000000000000000000'
      code: |
       { 

         [[0]] 0x60A7

        ; Write to @@0, and see how much gas that cost. It should
        ; cost more when it is not declared storage
          [0]   (gas)
         [[0]]  0x02 
          [0]   (- @0 (gas) 17)
         [[1]] @0

        ; The 17 is the cost of the extra opcodes:
        ; PUSH1 0x00, MSTORE
        ; PUSH1 0x02, PUSH1 0x00, (and then comes the SSTORE we are measuring)
        ; GAS

        ; Since this is second access, it will cost 103
        ; regardless of whether it was declared or not

       }
      nonce: '0'
      storage: {}



    # Declared vs. undeclared read (SLOAD), after writing to the storage
    0000000000000000000000000000000000000111:
      balance: '1000000000000000000'
      code: |
       { 
         [[0]] 0x60A7

        ; Read @@0, and see how much gas that cost. It should
        ; cost more when it is not declared storage
          [0]   (gas)
          @@0 
          [0]   (- @0 (gas) 19)
         [[1]] @0

        ; Since this is second access, it will cost 100
        ; regardless of whether it was declared or not
       }
      nonce: '0'
      storage: {}


    # Declared vs. undeclared write (SSTORE), after reading the storage
    0000000000000000000000000000000000000120:
      balance: '1000000000000000000'
      code: |
       { 
         [0x20] @@0

        ; Write to @@0, and see how much gas that cost. It should
        ; cost more when it is not declared storage
          [0]   (gas)
         [[0]]  0x02 
          [0]   (- @0 (gas) 17)
         [[1]] @0

        ; The 17 is the cost of the extra opcodes:
        ; PUSH1 0x00, MSTORE
        ; PUSH1 0x02, PUSH1 0x00, (and then comes the SSTORE we are measuring)
        ; GAS

        ; Since this is second access, it will cost 20k
        ; regardless of whether it was declared or not

       }
      nonce: '0'
      storage: {}



    # Declared vs. undeclared read (SLOAD), after already reading it
    0000000000000000000000000000000000000121:
      balance: '1000000000000000000'
      code: |
       { 
         [0x20] @@0

        ; Read @@0, and see how much gas that cost.
          [0]   (gas)
          @@0 
          [0]   (- @0 (gas) 19)
         [[1]] @0

        ; Since this is second access, it will cost 97
        ; regardless of whether it was declared or not
       }
      nonce: '0'
      storage: {}




    # Call different contracts depending on the parameter
    cccccccccccccccccccccccccccccccccccccccc:
      balance: '0x0ba1a9ce0ba1a9ce'
      code: |
        {  
            (call (gas) (+ 0x100 $4) 0 0 0 0 0)
        }  
      nonce: '0'
      storage: {}



    a94f5374fce5edbc8e2a8697c15331677e6ebf0b:
      balance: '1000000000000000000'
      code: 0x
      nonce: '0'
      storage: {}


  transaction:
    data:
    # There is just one way to validly declare that a key will be used
    - data: :label declaredKeyWrite :abi f(uint) 0
      accessList:
      - address: 0x0000000000000000000000000000000000000100
        storageKeys:
        - 0x00
    - data: :label declaredKeyRead :abi f(uint) 1
      accessList:
      - address: 0x0000000000000000000000000000000000000101
        storageKeys:
        - 0x00
    - data: :label declaredKeyDel :abi f(uint) 2
      accessList:
      - address: 0x0000000000000000000000000000000000000102
        storageKeys:
        - 0x00
    - data: :label declaredKeyUpdate :abi f(uint) 3
      accessList:
      - address: 0x0000000000000000000000000000000000000103
        storageKeys:
        - 0x00
    - data: :label declaredKeyNOP :abi f(uint) 4
      accessList:
      - address: 0x0000000000000000000000000000000000000104
        storageKeys:
        - 0x00


    
    # But there are multiple ways to get it wrong:
    # Wrong storageKey
    - data: :label undeclaredKeyWrite :abi f(uint) 0
      accessList:
      - address: 0x0000000000000000000000000000000000000100
        storageKeys:
        - 0x10
    - data: :label undeclaredKeyRead :abi f(uint) 1
      accessList:
      - address: 0x0000000000000000000000000000000000000101
        storageKeys:
        - 0x10
    - data: :label undeclaredKeyDel :abi f(uint) 2
      accessList:
      - address: 0x0000000000000000000000000000000000000102
        storageKeys:
        - 0x10
    - data: :label undeclaredKeyUpdate :abi f(uint) 3
      accessList:
      - address: 0x0000000000000000000000000000000000000103
        storageKeys:
        - 0x10
    - data: :label undeclaredKeyNOP :abi f(uint) 4
      accessList:
      - address: 0x0000000000000000000000000000000000000104
        storageKeys:
        - 0x10

    # Wrong address
    - data: :label undeclaredKeyWrite :abi f(uint) 0
      accessList:
      - address: 0xF000000000000000000000000000000000000100
        storageKeys:
        - 0x00
    - data: :label undeclaredKeyRead :abi f(uint) 1
      accessList:
      - address: 0xF000000000000000000000000000000000000101
        storageKeys:
        - 0x00
    - data: :label undeclaredKeyDel :abi f(uint) 2
      accessList:
      - address: 0xF000000000000000000000000000000000000101
        storageKeys:
        - 0x00
    - data: :label undeclaredKeyUpdate :abi f(uint) 3
      accessList:
      - address: 0xF000000000000000000000000000000000000101
        storageKeys:
        - 0x00
    - data: :label undeclaredKeyNOP :abi f(uint) 4
      accessList:
      - address: 0xF000000000000000000000000000000000000101
        storageKeys:
        - 0x00

    # No access list at all
    - :label undeclaredKeyWrite  :abi f(uint) 0
    - :label undeclaredKeyRead   :abi f(uint) 1
    - :label undeclaredKeyDel    :abi f(uint) 2
    - :label undeclaredKeyUpdate :abi f(uint) 3
    - :label undeclaredKeyNOP    :abi f(uint) 4


    # If we had already accessed the storage (and paid the penalty
    # in case it was undeclared), it doesn't matter how we accessed it then
    # or how we access it now. The cost is the same regardless of whether
    # we declared the key in the storage list or not
    - data: :label declaredKeyWrite_postSSTORE :abi f(uint) 0x10
      accessList:
      - address: 0x0000000000000000000000000000000000000110
        storageKeys:
        - 0x00
    - data: :label undeclaredKeyWrite_postSSTORE :abi f(uint) 0x10
      accessList:
      - address: 0x0000000000000000000000000000000000000110
        storageKeys:
        - 0x10
    - data: :label declaredKeyRead_postSSTORE :abi f(uint) 0x11
      accessList:
      - address: 0x0000000000000000000000000000000000000111
        storageKeys:
        - 0x00
    - data: :label undeclaredKeyRead_postSSTORE :abi f(uint) 0x11
      accessList:
      - address: 0x0000000000000000000000000000000000000111
        storageKeys:
        - 0x10
    - data: :label declaredKeyWrite_postSLOAD :abi f(uint) 0x20
      accessList:
      - address: 0x0000000000000000000000000000000000000120
        storageKeys:
        - 0x00
    - data: :label undeclaredKeyWrite_postSLOAD :abi f(uint) 0x20
      accessList:
      - address: 0x0000000000000000000000000000000000000120
        storageKeys:
        - 0x10
    - data: :label declaredKeyRead_postSLOAD :abi f(uint) 0x21
      accessList:
      - address: 0x0000000000000000000000000000000000000121
        storageKeys:
        - 0x00
    - data: :label undeclaredKeyRead_postSLOAD :abi f(uint) 0x21
      accessList:
      - address: 0x0000000000000000000000000000000000000121
        storageKeys:
        - 0x10


    # Do a complex access list, see that it is still processed 
    # correctly
    # There is just one way to validly declare that a key will
    # be used
    - data: :label declaredKeyWrite :abi f(uint) 0
      accessList:
      - address: 0x00000000000000000000000000000000000060A7
        storageKeys:
        - 0xFFFFFad
        - 0x00ad
        - 0x123214342ad
        - 0xdeadbeef
      - address: 0x0000000000000000000000000000000000000100
        storageKeys:
        - 0xFFFFF
        - 0x00
        - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        - 0x123214342
        - 0xdeadbeef
      - address: 0x0000000000000000000000000010000000000100
        storageKeys:
        - 0xFFFFFbc
        - 0x00bc
        - 0x123214342bc
        - 0xdeadbeefbc
      - address: 0xffffffffffffffffffffffffffffffffffffffff
        storageKeys:
        - 0xFFFFFbc
        - 0x00bc
        - 0x123214342bc
        - 0xdeadbeefbc
        - 0xdeadbeef12345678deadbeef12345678deadbeef12345678deadbeef12345678
        - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff


    gasLimit:
    - '400000'
    gasPrice: '1'
    nonce: '0'
    secretKey: 45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d8
    to: cccccccccccccccccccccccccccccccccccccccc

    value:
    - '100000'






  expect:

  # Write to a previously unused storage cell, which is declared in the access list
  - indexes:
      data: :label declaredKeyWrite
      gas: !!int -1
      value: !!int -1
    network:
    - ">=Berlin"
    result:
      0000000000000000000000000000000000000100:
        storage:
          0x00: 0x02
          0x01: 0x4e23

  # Write to a previously unused storage cell, which is not declared in the access list
  - indexes:
      data: :label undeclaredKeyWrite
      gas: !!int -1
      value: !!int -1
    network:
    - ">=Berlin"
    result:
      0000000000000000000000000000000000000100:
        storage:
          0x00: 0x02
          0x01: 0x5657



  # Write to a previously used storage cell, which is declared in the access list
  - indexes:
      data: :label declaredKeyUpdate
      gas: !!int -1
      value: !!int -1
    network:
    - ">=Berlin"
    result:
      0000000000000000000000000000000000000103:
        storage:
          0x00: 0xBEEF
          0x01: 0x0b57

  # Write to a previously used storage cell, which is not declared in the access list
  - indexes:
      data: :label undeclaredKeyUpdate
      gas: !!int -1
      value: !!int -1
    network:
    - ">=Berlin"
    result:
      0000000000000000000000000000000000000103:
        storage:
          0x00: 0xBEEF
          0x01: 0x138b


  # Write to a previously used storage cell, but the same value it currently has
  # This cell is declared in the access list
  - indexes:
      data: :label declaredKeyNOP
      gas: !!int -1
      value: !!int -1
    network:
    - ">=Berlin"
    result:
      0000000000000000000000000000000000000104:
        storage:
          0x00: 0x60A7
          0x01: 0x0067


  # Write to a previously used storage cell, but the same value it currently has
  # This cell is not declared in the access list
  - indexes:
      data: :label undeclaredKeyNOP
      gas: !!int -1
      value: !!int -1
    network:
    - ">=Berlin"
    result:
      0000000000000000000000000000000000000104:
        storage:
          0x00: 0x60A7
          0x01: 0x089b


  # Write zero to a previously used storage cell, freeing it
  # This cell is declared in the access list
  #
  # Note that we don't see the refund for freeing storage, that happens at the
  # end of the transaction
  - indexes:
      data: :label declaredKeyDel
      gas: !!int -1
      value: !!int -1
    network:
    - ">=Berlin"
    result:
      0000000000000000000000000000000000000102:
        storage:
          0x00: 0x00
          0x01: 0x0b57



  # Write zero to a previously used storage cell, freeing it
  # This cell is not declared in the access list
  #
  # Note that we don't see the refund for freeing storage, that happens at the
  # end of the transaction
  - indexes:
      data: :label undeclaredKeyDel
      gas: !!int -1
      value: !!int -1
    network:
    - ">=Berlin"
    result:
      0000000000000000000000000000000000000102:
        storage:
          0x00: 0x00
          0x01: 0x138b



  # Read a storage cell that has been declared in the access list
  - indexes:
      data: :label declaredKeyRead
      gas: !!int -1
      value: !!int -1
    network:
    - ">=Berlin"
    result:
      0000000000000000000000000000000000000101:
        storage:
          0x01: 0x0064



  # Read a storage cell that has not been declared in the access list
  - indexes:
      data: :label undeclaredKeyRead
      gas: !!int -1
      value: !!int -1
    network:
    - ">=Berlin"
    result:
      0000000000000000000000000000000000000101:
        storage:
          0x01: 0x0834



  # Do an SSTORE, and then check the cost of a second SSTORE for the same cell
  # The cost of the second access is the same whether it was declared in the access
  # list or not.
  - indexes:
      data:
      - :label declaredKeyWrite_postSSTORE
      - :label undeclaredKeyWrite_postSSTORE
      gas: !!int -1
      value: !!int -1
    network:
    - ">=Berlin"
    result:
      0000000000000000000000000000000000000110:
        storage:
          0x00: 0x02
          0x01: 0x0067




  # Do an SSTORE, and then check the cost of an SLOAD for the same cell
  # The cost of the second access is the same whether it was declared in the access
  # list or not.
  - indexes:
      data:
      - :label declaredKeyRead_postSSTORE
      - :label undeclaredKeyRead_postSSTORE
      gas: !!int -1
      value: !!int -1
    network:
    - ">=Berlin"
    result:
      0000000000000000000000000000000000000111:
        storage:
          0x00: 0x60A7
          0x01: 0x0064



  # Do an SLOAD, and then check the cost of an SSTORE for the same cell
  # The cost of the second access is the same whether it was declared in the access
  # list or not.
  - indexes:
      data:
      - :label declaredKeyWrite_postSLOAD
      - :label undeclaredKeyWrite_postSLOAD
      gas: !!int -1
      value: !!int -1
    network:
    - ">=Berlin"
    result:
      0000000000000000000000000000000000000120:
        storage:
          0x00: 0x02
          0x01: 0x4e20



  # Do an SLOAD, and then check the cost of a second SLOAD for the same cell
  # The cost of the second access is the same whether it was declared in the access
  # list or not.
  - indexes:
      data:
      - :label declaredKeyRead_postSLOAD
      - :label undeclaredKeyRead_postSLOAD
      gas: !!int -1
      value: !!int -1
    network:
    - ">=Berlin"
    result:
      0000000000000000000000000000000000000121:
        storage:
          0x01: 0x0061






